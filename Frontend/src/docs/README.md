# Sirius

Welcome to the developer documentation for Sirius, a layer of observability, governance, and attestation for distributed storage systems. Sirius focuses on providing cryptographic guarantees for data integrity, versioning, and AI reproducibility while ensuring high availability and reliability.

> **Fun fact**
>
> Sirius is designed to work seamlessly with existing distributed storage systems like Walrus, adding trust and traceability layers without modifying the underlying protocols.

## The Problem

Distributed storage systems like Walrus guarantee that data exists and can be retrieved, but they do not guarantee that data is:
- **Authentic** â€” free from tampering
- **Consistent** â€” the same across all nodes
- **Traceable** â€” with a verifiable history of changes

## Our Solution

Sirius addresses these gaps by introducing an intelligent overlay that:

1. **Monitors versions** and detects divergences between nodes
2. **Automatically canonizes** the valid version via adaptive anchors on the Sui blockchain
3. **Produces AI reproducibility proofs** when a model uses a dataset

In other words, Sirius transforms distributed storage into a verifiable trust and traceability platform, where each dataset has:
- A cryptographic identity
- A complete evolution history
- AI attestations guaranteeing its integrity

The solution remains compatible with existing storage infrastructure, without modifying the underlying protocol.

## Architecture

### 1. Data Layer (Integrity and Versioning)

- Groups files into an ordered manifest (list of `blob_id` + metadata)
- Calculates a global fingerprint (Merkle root) of this manifest
- Links each version to the previous one (`parent_root`) to build a version chain (Merkle-chain)
- Version commits are signed and can be stored in Ceramic/IPLD for fast reading
- Every N minutes (epoch) or in case of an alert, a Merkle-of-Merkle anchor is published on the Sui blockchain, freezing a dataset state

**Goal:** obtain, for each dataset, an immutable identity and verifiable history without gas overhead.

### 2. AI Layer (Surveillance and Governance)

- Collects lightweight fingerprints (statistical summaries, MinHash, Bloom Filter, quantized embeddings) generated by storage nodes or lightweight probes
- Analyzes inter-node consistency: if fingerprints diverge, the model evaluates a `risk_score`
- If this score exceeds a threshold, the AI automatically triggers an adaptive anchor of the new version
- The AI also calculates an `integrity_score` for each node and a dynamic reputation score (weighted moving average of past behaviors)
- This information is recorded in a global snapshot for audit

### 3. On-chain Anchoring (Blockchain Layer)

On the Sui blockchain, three types of transactions are used:

- `anchor_epoch` â€” publishes the Merkle root of a batch of commits (batched epochs)
- `submit_snapshot` â€” records inter-node consistency (k-of-n signatures, average of `integrity_scores`)
- `record_receipt` â€” records AI reproducibility receipts (link between a model, a dataset, a version and its performance)

These anchors are public, consultable by any actor and form the basis of cryptographic verification of the system.

### 4. User Dashboard

Web interface displaying:
- the version chain (DAG)
- the last state anchored on Sui
- `integrity_scores` and node reputations
- associated reproducibility receipts

Allows visualization of the complete traceability of a dataset and knowing which version is "canonical" at a given time.

## Key Improvements Over Walrus

While Walrus provides excellent data availability guarantees, Sirius adds:

- **Version integrity** â€” Cryptographic proof that data hasn't been tampered with
- **Automatic divergence detection** â€” AI-powered monitoring of node consistency
- **Adaptive anchoring** â€” Smart on-chain anchoring only when needed, reducing costs
- **AI reproducibility** â€” Cryptographic proofs linking models to exact data versions
- **Complete traceability** â€” Full history of every dataset version

## Module Behavior

### ðŸ”¸ Adaptive Canonicalization

The system anchors a new version on Sui only:
- When a divergence risk is detected (fork or inconsistency)
- Or at fixed epoch intervals

â†’ Reduced on-chain cost and better temporal consistency.

### ðŸ”¸ Integrity Surveillance

Fingerprints are produced locally; no raw data transfer.

The AI compares lightweight signatures to detect content differences.

If a node distributes an altered blob, its `integrity_score` drops and it is flagged.

### ðŸ”¸ Reputation and Snapshot Consensus

At each epoch, an aggregator collects signatures and scores from multiple nodes.

It validates k-of-n consistency and publishes a unique snapshot with integrity average and list of faulty nodes.

Reputation evolves according to the historical reliability of each node (smoothed score).

### ðŸ”¸ Reproducibility Receipts

Each AI execution (training, evaluation, inference) generates a receipt:

```
hash(model_id, code_hash, dataset_id, version_root, hyperparams, metrics)
```

This hash is recorded on Sui and links the model to the exact data version used, ensuring scientific reproducibility.

## Key Advantages

- **Verifiable traceability** â€” Each dataset has a cryptographic identity and complete history
- **Automatic divergence detection** â€” Continuous monitoring of consistency between nodes
- **Adaptive canonicalization** â€” Smart anchoring only when necessary, reducing costs
- **AI reproducibility** â€” Cryptographic proofs linking models and data versions
- **Compatible** â€” No modification of the underlying storage system required

## Performance Indicators

- **Mean Integrity Score** â€” average consistency of nodes per epoch
- **Average Risk Score** â€” rate of detected forks / total epochs
- **Reduced anchoring cost** â€” average number of commits per transaction
- **Reproducibility pass rate** â€” proportion of validated receipts
- **Time-to-anchor** â€” average delay between detected fork and effective anchoring

## Organization

This documentation is organized into several parts:

1. _Architecture_ describes the functional architecture and system components
2. _Data Layer_ describes the integrity and versioning layer
3. _AI Layer_ describes the surveillance and governance layer
4. _On-chain_ describes integration with the Sui blockchain
5. _Dashboard_ describes the user interface and visualizations
6. _Usage_ provides concrete information for developers

